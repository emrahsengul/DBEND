<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GRP Dirsek Çizim Modülü v1.0</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        :root {
            --bg-color: #f3f6f9;
            --panel-bg: #1e1e2d;
            --panel-text: #ffffff;
            --accent: #009ef7;
            --accent-hover: #0073e9;
            --border-color: #323248;
            --table-border: #000;
        }

        body {
            font-family: 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--bg-color);
            margin: 0; padding: 0; height: 100vh;
            display: flex; overflow: hidden;
        }

        /* --- SOL PANEL (KONTROLLER) --- */
        .sidebar {
            width: 320px;
            background-color: var(--panel-bg);
            color: var(--panel-text);
            display: flex; flex-direction: column;
            padding: 20px;
            box-shadow: 5px 0 15px rgba(0,0,0,0.1);
            z-index: 20;
            overflow-y: auto;
        }

        .brand {
            font-size: 1.3rem; font-weight: 700; color: white;
            padding-bottom: 20px; border-bottom: 1px solid var(--border-color);
            margin-bottom: 20px; display: flex; align-items: center; gap: 10px;
        }
        .brand i { color: var(--accent); }

        .control-group { margin-bottom: 15px; }
        .control-group label {
            display: block; font-size: 0.8rem; color: #a1a5b7; margin-bottom: 5px; font-weight: 600;
        }
        .control-group input, .control-group select {
            width: 100%; padding: 10px;
            background: #151521; border: 1px solid var(--border-color);
            color: white; border-radius: 6px; font-size: 0.9rem;
            box-sizing: border-box; transition: 0.2s;
        }
        .control-group input:focus { border-color: var(--accent); outline: none; }
        .control-group input[readonly] { background: #2b2b40; color: #7239ea; font-weight: bold; }

        .row { display: flex; gap: 10px; }
        .col { flex: 1; }

        button {
            width: 100%; padding: 12px; border: none; border-radius: 6px;
            cursor: pointer; font-weight: 600; font-size: 0.95rem;
            margin-top: 10px; display: flex; align-items: center; justify-content: center; gap: 8px;
            transition: all 0.2s;
        }
        .btn-update { background-color: var(--accent); color: white; }
        .btn-update:hover { background-color: var(--accent-hover); }
        
        .btn-print { background-color: #2b2b40; color: #e4e6ef; margin-top: 20px; border: 1px solid var(--border-color); }
        .btn-print:hover { background-color: #323248; color: white; }

        /* Sol Paneldeki Rapor Alanı (Opsiyonel hızlı bakış) */
        .quick-stats {
            margin-top: auto; padding-top: 20px; border-top: 1px solid var(--border-color);
            font-size: 0.8rem; color: #7e8299;
        }

        /* --- SAĞ PANEL (ÇİZİM) --- */
        .workspace {
            flex: 1; display: flex; justify-content: center; align-items: center;
            background-color: #e4e6ef;
            padding: 30px; position: relative;
        }

        #paper {
            background: white;
            box-shadow: 0 0 30px rgba(0,0,0,0.15);
            /* A4 Yatay Oranını Koru */
            aspect-ratio: 297/210;
            width: 100%; max-width: 1200px;
            position: relative;
        }

        svg { width: 100%; height: 100%; display: block; }

        /* YAZDIRMA AYARLARI */
        @media print {
            @page { size: A4 landscape; margin: 0; }
            body { background: white; display: block; }
            .sidebar { display: none !important; }
            .workspace { padding: 0; background: white; display: block; height: 100%; width: 100%; }
            #paper { box-shadow: none; width: 100% !important; max-width: none !important; height: 100% !important; border: none; }
        }
    </style>
</head>
<body>

<div class="sidebar">
    <div class="brand">
        <i class="fas fa-drafting-compass"></i> GRP Dirsek Çizim
    </div>

    <div class="control-group">
        <label>DN (Anma Çapı - mm)</label>
        <input type="number" id="dn" value="600" onchange="draw()">
    </div>

    <div class="control-group">
        <label>Dirsek Açısı (°)</label>
        <input type="number" id="angle" value="90" min="1" max="179" oninput="draw()">
    </div>

    <div class="control-group">
        <label>Segment Sayısı</label>
        <input type="number" id="segments" value="4" readonly title="Açıya göre otomatik hesaplanır">
    </div>

    <div class="row">
        <div class="col control-group">
            <label>Giriş L1 (mm)</label>
            <input type="number" id="l1" value="2000" onchange="draw()">
        </div>
        <div class="col control-group">
            <label>Giriş Tipi</label>
            <select id="typeIn" onchange="draw()">
                <option value="flange">Flanş</option>
                <option value="coupling">Manşon</option>
                <option value="plain">Düz</option>
            </select>
        </div>
    </div>

    <div class="row">
        <div class="col control-group">
            <label>Çıkış L2 (mm)</label>
            <input type="number" id="l2" value="2000" onchange="draw()">
        </div>
        <div class="col control-group">
            <label>Çıkış Tipi</label>
            <select id="typeOut" onchange="draw()">
                <option value="flange">Flanş</option>
                <option value="coupling">Manşon</option>
                <option value="plain">Düz</option>
            </select>
        </div>
    </div>

    <button class="btn-update" onclick="draw()"><i class="fas fa-sync"></i> Güncelle</button>
    <button class="btn-print" onclick="window.print()"><i class="fas fa-file-pdf"></i> Yazdır / PDF</button>

    <div class="quick-stats" id="statusMsg">
        Durum: Hazır
    </div>
</div>

<div class="workspace">
    <div id="paper">
        <svg id="svgCanvas" viewBox="0 0 2970 2100" preserveAspectRatio="xMidYMid meet"></svg>
    </div>
</div>

<script>
    const SVG_NS = "http://www.w3.org/2000/svg";

    function createSVG(tag, attrs) {
        const el = document.createElementNS(SVG_NS, tag);
        for (let k in attrs) el.setAttribute(k, attrs[k]);
        return el;
    }
    function toRad(deg) { return deg * Math.PI / 180; }
    function toDeg(rad) { return rad * 180 / Math.PI; }

    // Otomatik Segment Kuralı
    function calculateSegments(angle) {
        if (angle <= 31) return 2;
        if (angle <= 61) return 3;
        return 4;
    }

    function draw() {
        const svg = document.getElementById('svgCanvas');
        svg.innerHTML = '';

        // 1. PARAMETRELER
        const DN = parseFloat(document.getElementById('dn').value) || 600;
        const AngleDeg = parseFloat(document.getElementById('angle').value) || 90;
        const L1 = parseFloat(document.getElementById('l1').value) || 0;
        const L2 = parseFloat(document.getElementById('l2').value) || 0;
        const TypeIn = document.getElementById('typeIn').value;
        const TypeOut = document.getElementById('typeOut').value;
        
        // Segmenti güncelle
        const Segments = calculateSegments(AngleDeg);
        document.getElementById('segments').value = Segments;

        const R_Factor = 1.5;
        const R = DN * R_Factor;
        
        // 2. GEOMETRİ HESAPLAMA
        // Referans Sistemi: Merkez (0,0) dirsek dönüş merkezi.
        // Giriş: (-R, 0) noktasından başlar (Eğer L1=0 ise).
        // Giriş Borusu Vektörü: (-1, 0) yönünde uzar (Sola doğru).
        // Standart Görünüm: Soldan gelip, Sağa Aşağı dönen (veya yukarı).
        // Kullanıcı isteğine en uygun ve hatasız geometri:
        // Dirsek Başlangıç (Giriş): 180° (PI). Nokta (-R, 0).
        // Dönüş Yönü: Saat yönü (Açı azalır) -> 180'den (180-Angle)'a.
        // Veya Saat yönü tersi (Açı artar) -> 180'den (180+Angle)'a.
        // Teknik resimde genelde "Soldan Sağa ve Yukarı" kullanılır.
        // Başlangıç Açısı: 270° (-90°). Nokta (0, -R). Teğet (+1, 0). -> Giriş Yatay.
        // Dönüş: Pozitif (Saat yönü tersi). Bitiş: -90 + Açı.

        const startRad = -Math.PI / 2; // -90 Derece (270)
        const endRad = startRad + toRad(AngleDeg);

        const rOuter = R + DN/2;
        const rInner = R - DN/2;

        let ptsCenter = [], ptsOuter = [], ptsInner = [];

        // Dirsek Yayı Noktaları
        for(let i=0; i<=Segments; i++) {
            let t = i/Segments;
            let ang = startRad + t * (endRad - startRad);
            
            ptsCenter.push({x: Math.cos(ang)*R, y: Math.sin(ang)*R, ang: ang});
            ptsOuter.push({x: Math.cos(ang)*rOuter, y: Math.sin(ang)*rOuter});
            ptsInner.push({x: Math.cos(ang)*rInner, y: Math.sin(ang)*rInner});
        }

        // L1 (Giriş) - Sola Uzatma
        // (0, -R) noktasındayız. Teğet (+1, 0). Geriye (-1, 0) gideceğiz.
        const pInCenter = { x: ptsCenter[0].x - L1, y: ptsCenter[0].y };
        const pInOuter = { x: ptsOuter[0].x - L1, y: ptsOuter[0].y };
        const pInInner = { x: ptsInner[0].x - L1, y: ptsInner[0].y };

        // L2 (Çıkış) - Teğet Yönünde Uzatma
        const lastAng = ptsCenter[Segments].ang;
        // Teğet Vektörü (Normalin 90 derece döndürülmüş hali)
        // Normal (cos, sin). Teğet (-sin, cos).
        const vx = -Math.sin(lastAng);
        const vy = Math.cos(lastAng);
        
        const pOutCenter = { x: ptsCenter[Segments].x + vx * L2, y: ptsCenter[Segments].y + vy * L2 };
        const pOutOuter = { x: ptsOuter[Segments].x + vx * L2, y: ptsOuter[Segments].y + vy * L2 };
        const pOutInner = { x: ptsInner[Segments].x + vx * L2, y: ptsInner[Segments].y + vy * L2 };

        // 3. BOYUTLANDIRMA VE YERLEŞİM (AKILLI KADRAJ)
        // Tüm çizim noktalarını topla
        let allX = [pInOuter.x, pOutOuter.x, 0];
        let allY = [pInOuter.y, pOutOuter.y, 0];
        ptsOuter.forEach(p => { allX.push(p.x); allY.push(p.y); });
        
        // Dirsek şekli genelde L formundadır.
        // Çizimin Bounding Box'ı
        const drawMinX = Math.min(...allX);
        const drawMaxX = Math.max(...allX);
        const drawMinY = Math.min(...allY);
        const drawMaxY = Math.max(...allY);
        const drawW = drawMaxX - drawMinX;
        const drawH = drawMaxY - drawMinY;

        // Yazı Boyutu (Scale Factor)
        const fs = Math.max(DN * 0.05, drawW * 0.015);
        const strokeW = fs * 0.08;

        // A4 Oranında (297/210) bir "Kağıt" alanı yarat.
        // Çizimi kağıdın merkezine yerleştir ama tablo için yer ayır.
        // Sol tarafta tablo istendiği için, sol tarafa extra padding verelim.
        
        // Tablo Boyutları (Tahmini)
        const tableW = Math.max(drawW * 0.4, fs * 25); 
        const tableH = fs * 12; // Daha detaylı olduğu için yüksek

        // ViewBox Hesabı: Çizim + Tablo için yer
        // Tabloyu çizimin SOL ALT köşesine (veya en uygun boşluğa) koyacağız.
        // Çizimin soluna margin ekleyelim.
        
        const margin = fs * 5;
        // Sol kenar: Tablo sığacak kadar genişlet
        const viewMinX = Math.min(drawMinX, drawMinX - tableW * 0.2) - margin; 
        const viewMaxX = Math.max(drawMaxX, drawMinX + tableW + margin); // En az tablo kadar genişlik
        
        // Tablonun konumu:
        // Sol alt köşe (Standart)
        // Çizim genelde yukarı doğru gidiyor, alt taraf boş.
        let tableX = viewMinX + margin;
        let tableY = drawMaxY + margin; // Çizimin altına koyalım, daha temiz.

        // Kullanıcı "Solda" istedi. Çizimin solunda boşluk varsa oraya alalım.
        // Eğer çizim çok uzunsa (L1 büyük), sol taraf doludur. O zaman mecburen alta.
        // Ama biz "Akıllı" davranalım: 
        // Viewbox'ı tabloyu kapsayacak şekilde genişletelim.
        
        const finalMinX = Math.min(drawMinX, tableX);
        const finalMaxX = Math.max(drawMaxX, tableX + tableW);
        const finalMinY = Math.min(drawMinY, tableY - tableH); // Eğer üste koyarsak
        const finalMaxY = Math.max(drawMaxY, tableY + tableH);

        const vW = finalMaxX - finalMinX + margin*2;
        const vH = finalMaxY - finalMinY + margin*2;

        svg.setAttribute('viewBox', `${finalMinX - margin} ${drawMinY - margin} ${vW} ${drawMaxY - drawMinY + tableH + margin*3}`);

        // 4. DEFS (OKLAR VE TARAMA)
        const defs = createSVG('defs', {});
        defs.innerHTML = `
            <marker id="arrow" markerWidth="6" markerHeight="6" refX="5" refY="3" orient="auto">
                <path d="M0,0 L0,6 L6,3 z" fill="#000" />
            </marker>
             <pattern id="hatch" width="20" height="20" patternTransform="rotate(45 0 0)" patternUnits="userSpaceOnUse">
                <line x1="0" y1="0" x2="0" y2="20" style="stroke:#ccc; stroke-width:1" />
            </pattern>
        `;
        svg.appendChild(defs);

        // 5. ANA ÇİZİM
        let d = `M ${pInOuter.x} ${pInOuter.y}`; 
        d += ` L ${ptsOuter[0].x} ${ptsOuter[0].y}`;
        for(let i=1; i<=Segments; i++) d += ` L ${ptsOuter[i].x} ${ptsOuter[i].y}`;
        d += ` L ${pOutOuter.x} ${pOutOuter.y}`;
        d += ` L ${pOutInner.x} ${pOutInner.y}`;
        d += ` L ${ptsInner[Segments].x} ${ptsInner[Segments].y}`;
        for(let i=Segments-1; i>=0; i--) d += ` L ${ptsInner[i].x} ${ptsInner[i].y}`;
        d += ` L ${pInInner.x} ${pInInner.y}`;
        d += " Z";

        svg.appendChild(createSVG('path', {
            d: d, fill: "url(#hatch)", stroke: "black", "stroke-width": strokeW
        }));

        // Eksen
        let cd = `M ${pInCenter.x} ${pInCenter.y} L ${ptsCenter[0].x} ${ptsCenter[0].y}`;
        for(let i=1; i<=Segments; i++) cd += ` L ${ptsCenter[i].x} ${ptsCenter[i].y}`;
        cd += ` L ${pOutCenter.x} ${pOutCenter.y}`;
        svg.appendChild(createSVG('path', {
            d: cd, fill: "none", stroke: "red", "stroke-dasharray": `${fs},${fs/2}`, "stroke-width": strokeW*0.6
        }));

        // Kaynak Çizgileri
        for(let i=0; i<=Segments; i++) {
            svg.appendChild(createSVG('line', {
                x1: ptsOuter[i].x, y1: ptsOuter[i].y, x2: ptsInner[i].x, y2: ptsInner[i].y,
                stroke: "#444", "stroke-width": strokeW*0.5
            }));
        }

        // 6. OPSİYONLAR (FLANŞ/MANŞON)
        function drawFitting(cx, cy, ang, type, isStart) {
            if(type === 'plain') return;
            const g = createSVG('g', {transform: `translate(${cx},${cy}) rotate(${toDeg(ang)})`});
            const fw = Math.max(DN*0.15, fs);
            const fh = DN*1.45;
            const xOff = isStart ? -fw : 0;

            if(type === 'flange') {
                g.appendChild(createSVG('rect', {
                    x: xOff, y: -fh/2, width: fw, height: fh,
                    fill: "#e0e0e0", stroke: "black", "stroke-width": strokeW
                }));
            } else if(type === 'coupling') {
                 g.appendChild(createSVG('rect', {
                    x: -DN*0.3, y: -DN*0.6, width: DN*0.6, height: DN*1.2,
                    fill: "#b3d9ff", "fill-opacity":"0.5", stroke: "black", "stroke-width": strokeW
                }));
            }
            svg.appendChild(g);
        }
        drawFitting(pInCenter.x, pInCenter.y, 0, TypeIn, true);
        drawFitting(pOutCenter.x, pOutCenter.y, lastAng + Math.PI/2, TypeOut, false);


        // 7. ÖLÇÜLENDİRME VE ÇAP YAZISI
        function dim(x1, y1, x2, y2, txt, offset, color="black") {
            const dx = x2-x1, dy = y2-y1;
            const len = Math.sqrt(dx*dx+dy*dy);
            const nx = -dy/len, ny = dx/len;
            const off = DN*0.7*offset;
            const ox1 = x1+nx*off, oy1 = y1+ny*off;
            const ox2 = x2+nx*off, oy2 = y2+ny*off;
            
            const g = createSVG('g', {});
            g.appendChild(createSVG('line', {x1:x1,y1:y1,x2:ox1,y2:oy1, stroke:"#666", "stroke-width":strokeW/2}));
            g.appendChild(createSVG('line', {x1:x2,y1:y2,x2:ox2,y2:oy2, stroke:"#666", "stroke-width":strokeW/2}));
            g.appendChild(createSVG('line', {
                x1:ox1,y1:oy1,x2:ox2,y2:oy2, stroke:color, "stroke-width":strokeW*0.7,
                "marker-start":"url(#arrow)", "marker-end":"url(#arrow)"
            }));
            
            const mx = (ox1+ox2)/2, my = (oy1+oy2)/2;
            let ang = Math.atan2(dy,dx)*180/Math.PI;
            if(ang>90 || ang<-90) ang+=180;
            
            const t = createSVG('text', {
                x:mx, y:my, "text-anchor":"middle", "dy":-fs*0.3,
                "font-size":fs, "font-family":"Arial", "font-weight":"bold", fill:color,
                transform:`rotate(${ang},${mx},${my})`
            });
            t.textContent = txt;
            g.appendChild(t);
            svg.appendChild(g);
        }

        if(L1>0) dim(pInCenter.x, pInCenter.y, ptsCenter[0].x, ptsCenter[0].y, `L1=${L1}`, 1.2);
        if(L2>0) dim(ptsCenter[Segments].x, ptsCenter[Segments].y, pOutCenter.x, pOutCenter.y, `L2=${L2}`, -1.2);

        // ÇAP GÖSTERİMİ (İSTEK)
        // Giriş borusunun üzerine "Ø600" yazalım
        // Dikine bir ölçü çizgisi
        const pDia1 = pInOuter; 
        const pDia2 = pInInner;
        // Biraz geriden ölçü verelim
        const diaX = pInOuter.x + L1*0.2; // Girişten biraz içeride
        dim(pInOuter.x, pInOuter.y, pInInner.x, pInInner.y, `∅${DN}`, 0.5);

        // Açı
        svg.appendChild(createSVG('text', {
            x: 0, y: R*0.4, "text-anchor":"middle", "font-size":fs*1.5, fill:"blue", "font-weight":"bold"
        })).textContent = `${AngleDeg}°`;

        // 8. DETAYLI ÖZET TABLO (SOLDA & DİNAMİK)
        // Tabloyu çizimin altına, sola dayalı yerleştiriyoruz (Yukarıda hesaplanan tableX, tableY)
        const tG = createSVG('g', {transform: `translate(${tableX}, ${tableY})`});
        
        // Tablo Stili
        const headerH = fs * 2;
        const rowH = fs * 1.5;
        const col1W = tableW * 0.4;
        const col2W = tableW * 0.3;
        const col3W = tableW * 0.3;

        // Dış Çerçeve
        tG.appendChild(createSVG('rect', {
            x:0, y:0, width:tableW, height:tableH, fill:"white", stroke:"black", "stroke-width":strokeW
        }));

        // Başlık
        tG.appendChild(createSVG('rect', {x:0, y:0, width:tableW, height:headerH, fill:"#eee", stroke:"black", "stroke-width":strokeW/2}));
        const title = createSVG('text', {
            x:tableW/2, y:headerH/2, "text-anchor":"middle", "dy":fs*0.3,
            "font-size":fs, "font-weight":"bold", "font-family":"sans-serif"
        });
        title.textContent = "GRP İMALAT PLANI";
        tG.appendChild(title);

        // Satır Çizme Fonksiyonu
        const rows = [
            ["Parametre", "Değer", "Birim"],
            ["Anma Çapı", `DN ${DN}`, "mm"],
            ["Dirsek Açısı", `${AngleDeg}`, "Derece"],
            ["Yarıçap (R)", `${(DN*R_Factor).toFixed(0)}`, "mm"],
            ["Segment Sayısı", `${Segments}`, "Adet"],
            ["Basınç Sınıfı", "PN 10", "Bar"],
            ["Toplam Uzunluk", `${(L1+L2+(toRad(AngleDeg)*R)).toFixed(0)}`, "mm"],
            ["Malzeme", "GRP/CTP", "-"],
            ["Tarih", new Date().toLocaleDateString("tr-TR"), "-"]
        ];

        let curY = headerH;
        rows.forEach((row, i) => {
            // Çizgi
            tG.appendChild(createSVG('line', {x1:0, y1:curY, x2:tableW, y2:curY, stroke:"black", "stroke-width":strokeW/2}));
            
            // Hücreler
            const style = i===0 ? "font-weight:bold" : "";
            
            // Col 1
            const t1 = createSVG('text', {x:fs, y:curY+rowH*0.7, "font-size":fs*0.7, "font-family":"sans-serif", style:style});
            t1.textContent = row[0];
            tG.appendChild(t1);
            
            // Col 2
            const t2 = createSVG('text', {x:col1W+fs, y:curY+rowH*0.7, "font-size":fs*0.7, "font-family":"sans-serif", style:style});
            t2.textContent = row[1];
            tG.appendChild(t2);

            // Col 3
            if(row[2]) {
                const t3 = createSVG('text', {x:col1W+col2W+fs, y:curY+rowH*0.7, "font-size":fs*0.7, "font-family":"sans-serif", style:style});
                t3.textContent = row[2];
                tG.appendChild(t3);
            }

            curY += rowH;
        });

        // Dikey Çizgiler
        tG.appendChild(createSVG('line', {x1:col1W, y1:headerH, x2:col1W, y2:tableH, stroke:"black", "stroke-width":strokeW/2}));
        tG.appendChild(createSVG('line', {x1:col1W+col2W, y1:headerH, x2:col1W+col2W, y2:tableH, stroke:"black", "stroke-width":strokeW/2}));

        svg.appendChild(tG);

        document.getElementById('statusMsg').innerText = `Hesaplama Tamamlandı: Toplam ${rows.length-1} parametre işlendi.`;
    }

    window.onload = draw;
</script>

</body>
</html>
